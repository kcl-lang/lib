/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface ExternalPkg {
  pkgName: string
  pkgPath: string
}
/** kcl main.k -D name=value */
export interface Argument {
  name: string
  value: string
}
export interface Error {
  level: string
  code: string
  messages: Array<Message>
}
export interface Message {
  msg: string
  pos?: Position
}
export interface PingArgs {
  value: string
}
export interface PingResult {
  value: string
}
/** empty */
export interface ListMethodArgs {}
export interface ListMethodResult {
  methodNameList: Array<string>
}
export interface ParseFileArgs {
  path: string
  source: string
  externalPkgs: Array<ExternalPkg>
}
export interface ParseFileResult {
  /** JSON string value */
  astJson: string
  /** file dependency paths */
  deps: Array<string>
  /** Parse errors */
  errors: Array<Error>
}
export interface ParseProgramArgs {
  paths: Array<string>
  sources: Array<string>
  /** External packages path */
  externalPkgs: Array<ExternalPkg>
}
export interface ParseProgramResult {
  /** JSON string value */
  astJson: string
  /** Returns the files in the order they should be compiled */
  paths: Array<string>
  /** Parse errors */
  errors: Array<Error>
}
export interface LoadPackageResult {
  /** JSON string value */
  program: string
  /** Returns the files in the order they should be compiled */
  paths: Array<string>
  /** Parse errors */
  parseErrors: Array<Error>
  /** Type errors */
  typeErrors: Array<Error>
  /** Map key is the ScopeIndex json string. */
  scopes: Record<string, Scope>
  /** Map key is the SymbolIndex json string. */
  symbols: Record<string, symbol>
  /** Map key is the AST index UUID string. */
  nodeSymbolMap: Record<string, SymbolIndex>
  /** Map key is the SymbolIndex json string. */
  symbolNodeMap: Record<string, string>
  /** Map key is the fully_qualified_name e.g. `pkg.Name` */
  fullyQualifiedNameMap: Record<string, SymbolIndex>
  /** Map key is the package path. */
  pkgScopeMap: Record<string, ScopeIndex>
}
export interface ListOptionsResult {
  /** Returns the files in the order they should be compiled */
  options: Array<OptionHelp>
}
export interface OptionHelp {
  name: string
  type: string
  required: boolean
  defaultValue: string
  help: string
}
export interface Symbol {
  ty?: string
  name: string
  owner?: SymbolIndex
  def?: SymbolIndex
  attrs: Array<SymbolIndex>
  isGlobal: boolean
}
export interface Scope {
  kind: string
  parent?: ScopeIndex
  owner?: SymbolIndex
  children: Array<ScopeIndex>
  defs: Array<SymbolIndex>
}
export interface SymbolIndex {
  i: number
  g: number
  kind: string
}
export interface ScopeIndex {
  i: number
  g: number
  kind: string
}
export interface ExecProgramResult {
  jsonResult: string
  yamlResult: string
  logMessage: string
  errMessage: string
}
export interface BuildProgramResult {
  path: string
}
export interface ResetPluginArgs {
  pluginRoot: string
}
/** empty */
export interface ResetPluginResult {}
export interface FormatCodeArgs {
  source: string
}
export interface FormatCodeResult {
  formatted: Array<number>
}
export interface FormatPathArgs {
  path: string
}
export interface FormatPathResult {
  changedPaths: Array<string>
}
export interface LintPathArgs {
  paths: Array<string>
}
export interface LintPathResult {
  results: Array<string>
}
export interface OverrideFileResult {
  result: boolean
}
export interface ListVariablesResult {
  variables: Record<string, Variable>
  unsupportedCodes: Array<string>
  parseErrors: Array<Error>
}
export interface Variable {
  value: string
}
export interface GetSchemaTypeResult {
  schemaTypeList: Array<KclType>
}
export interface GetSchemaTypeMappingResult {
  schemaTypeMapping: Record<string, KclType>
}
export interface ValidateCodeArgs {
  datafile: string
  data: string
  file: string
  code: string
  schema: string
  attributeName: string
  format: string
}
export interface ValidateCodeResult {
  success: boolean
  errMessage: string
}
export interface Position {
  line: number
  column: number
  filename: string
}
export interface ListDepFilesArgs {
  workDir: string
  useAbsPath: boolean
  includeAll: boolean
  useFastParser: boolean
}
export interface ListDepFilesResult {
  pkgroot: string
  pkgpath: string
  files: Array<string>
}
export interface LoadSettingsFilesArgs {
  workDir: string
  files: Array<string>
}
export interface LoadSettingsFilesResult {
  kclCliConfigs?: CliConfig
  kclOptions: Array<KeyValuePair>
}
export interface CliConfig {
  files: Array<string>
  output: string
  overrides: Array<string>
  pathSelector: Array<string>
  strictRangeCheck: boolean
  disableNone: boolean
  verbose: number
  debug: boolean
  sortKeys: boolean
  showHidden: boolean
  includeSchemaTypePath: boolean
  fastEval: boolean
}
export interface KeyValuePair {
  key: string
  value: string
}
export interface RenameArgs {
  /** the file path to the package root */
  packageRoot: string
  /** the path to the target symbol to be renamed. The symbol path should conform to format: `<pkgpath>:<field_path>` When the pkgpath is '__main__', `<pkgpath>:` can be omitted. */
  symbolPath: string
  /** the paths to the source code files */
  filePaths: Array<string>
  /** the new name of the symbol */
  newName: string
}
export interface RenameResult {
  /** the file paths got changed */
  changedFiles: Array<string>
}
export interface RenameCodeArgs {
  /** the file path to the package root */
  packageRoot: string
  /** the path to the target symbol to be renamed. The symbol path should conform to format: `<pkgpath>:<field_path>` When the pkgpath is '__main__', `<pkgpath>:` can be omitted. */
  symbolPath: string
  /** the source code. a <filename>:<code> map */
  sourceCodes: Record<string, string>
  /** the new name of the symbol */
  newName: string
}
export interface RenameCodeResult {
  /** the changed code. a <filename>:<code> map */
  changedCodes: Record<string, string>
}
export interface TestResult {
  info: Array<TestCaseInfo>
}
export interface TestCaseInfo {
  /** Test case name */
  name: string
  error: string
  logMessage: string
}
export interface KclType {
  /** schema, dict, list, str, int, float, bool, any, union, number_multiplier */
  type: string
  /** union types */
  unionTypes: Array<KclType>
  /** default value */
  default: string
  /** schema name */
  schemaName: string
  /** schema doc */
  schemaDoc: string
  /** schema properties */
  properties: Record<string, KclType>
  /** required schema properties, [property_name1, property_name2] */
  required: Array<string>
  /** dict key type */
  key: KclType
  /** dict/list item type */
  item: KclType
  line: number
  /** schema decorators */
  decorators: Array<Decorator>
  /** `filename` represents the absolute path of the file name where the attribute is located. */
  filename: string
  /** `pkg_path` represents the path name of the package where the attribute is located. */
  pkgPath: string
  /** `description` represents the document of the attribute. */
  description: string
  /** A map object to hold examples, the key is the example name. */
  examples: Record<string, Example>
}
export interface Decorator {
  name: string
  arguments: Array<string>
  keywords: Record<string, string>
}
export interface Example {
  summary: string
  description: string
  value: string
}
export interface UpdateDependenciesResult {
  externalPkgs: Array<ExternalPkg>
}
export function loadPackage(args: LoadPackageArgs): LoadPackageResult
export function execProgram(args: ExecProgramArgs): ExecProgramResult
export function listVariables(args: ListVariablesArgs): ListVariablesResult
export function overrideFile(args: OverrideFileArgs): OverrideFileResult
export function updateDependencies(args: UpdateDependenciesArgs): UpdateDependenciesResult
export class LoadPackageArgs {
  constructor(
    paths: Array<string>,
    sources: Array<string>,
    resolveAst?: boolean | undefined | null,
    loadBuiltin?: boolean | undefined | null,
    withAstIndex?: boolean | undefined | null,
  )
}
export class ExecProgramArgs {
  constructor(paths: Array<string>, workDir?: string | undefined | null)
}
export class ListVariablesArgs {
  constructor(file: string, specs: Array<string>)
}
export class OverrideFileArgs {
  constructor(file: string, specs: Array<string>, importPaths: Array<string>)
}
export class UpdateDependenciesArgs {
  constructor(manifestPath: string, vendor: boolean)
}
